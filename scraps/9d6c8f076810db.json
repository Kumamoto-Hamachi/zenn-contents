{
  "title": "だいだい1週間で学ぶDocker",
  "closed": false,
  "archived": false,
  "created_at": "2021-04-19",
  "comments": [
    {
      "author": "kumamoto",
      "created_at": "2021-04-19",
      "body_markdown": "# Day1 Dockerの超基本概念を抑える\n![](https://storage.googleapis.com/zenn-user-upload/k60u2exhticj3gj83046xdepddws)\n\n# Dockerの基礎知識\n\n## Dockerとは\n**Docker**とは『コンテナを使用してアプリケーションの作成、デプロイ、実行を容易にするために設計されたツール』です。\n\n**コンテナ(container)** を使うと、『開発者は、アプリケーションに必要なライブラリやその他の依存関係などのパーツをすべてパッケージ化して、1つのパッケージとしてデプロイすることができます。』\n\nコンテナは **イメージ(image)** と呼ばれるコンテナの元から [**Docker Engine**](https://docs.docker.jp/engine/index.html) を使って作成します。\n\n※参考：[What is Docker? opensource.com](https://opensource.com/resources/what-docker)\n\n「上記の説明、なんのこっちゃ。。。」という方でもわかるようにまとめました。\n\n## Docker何がいい？ その１ 「独立した環境を作ることが出来る！」\n簡単に言えば**Docker**は**コンテナ**という独立した環境を用意してやるためのツールです。\n\nサーバーは用途に応じてWebサーバー(Apache、Nginxなど)やデータベース管理システム(MySQL、PostgreSQL、MariaDBなど)などのミドルウェアのインストールや各種設定を行います。\n\nこういったサーバーで複数のソフトウェアを同居させていて、 **あるソフトウェアをアップデートしたときに別のファイルも使用している共有のソフトウェアまでアップデートされてしまい不具合が生じる** ことがあります。\n\nこういった事象を防ぐために **コンテナという独立した箱を複数用意してやり、それぞれごとにソフトウェアをインストール/設定** してやれば良いというのがDockerのアイデアです。\n\nまた通常はサーバー1台の上に載せられるWebサーバーは1つですがコンテナ上のWebサーバーであれば複数(独立した環境で)同居させて動かす事ができます。\n\n## Docker何がいい？ その２ 「環境を簡単に作成/共有出来る！」\n\nDockerは\nこうしたコード化されたファイルを共有することで、どこでも **誰でも同じ環境が作ることが出来ます。** \nまたスクラップ＆ビルドが容易に出来るので **簡単に環境の変更についてテストすることも可能** です。\n\nまた開発サーバーでDockerを用いて作った環境はで本番サーバーに簡単に持っていくことが出来ます。\n\n## Dockerどう動いているのか？\n###  仮想化技術：ホストOS型(VirtualBox、VMWare)\nAWSのEC2はVirtualBoxやVMWareと同じ仮想化環境で動いています。\n### 仮想化技術：コンテナ型(Docker)\nコンテナの中にはLinuxカーネルの周辺部分と使用するソフトが入っているイメージ。\nつまり仮想的なOSやマシンを作っているというより独立した環境を持っているだけ。\n\n### 補足：MacやWindows上ではどう動いているのか\n(VirtualboxやVMwareのように)仮想環境にLinuxのシェル(Linuxのコア)を入れて動かしている。\nDockerはカーネルを共有して各ディストリビューションごとのプログラムを提供するだけなので。\n![](https://storage.googleapis.com/zenn-user-upload/rxvjgjq7h3t3q8cxj32xcvbrzl2u)\n\n\n## イメージとコンテナ\n**イメージ** は金型のようなもの。プログラマー向けに言うならOOP(オブジェクト指向)のクラスのようなものです。\n一方で **コンテナ** はその金型から出来た製品。OOPの世界のインスタンスです。\n\n金型(クラス)から製品(インスタンス)がいくらでも出来るようにイメージ一つから同じコンテナをいくらでも作ることが出来ます。\n\nまた逆にコンテナからイメージを作ることも出来ます！(製品から逆算して金型を作るようなものですね。)\n**既存のコンテナに少し手を加えたい** という時に **コンテナから作ったイメージにそれを反映させて再度コンテナを作り直す** ということも出来ます。\n\nまた、Dockerでは「1コンテナ=1アプリ」というのが基本の考え方になります。\n\n\n### コンテナのライフサイクル\nコンテナの **ライフサイクル** とは(1)作成(2)起動(3)停止(4)破棄、という一連の流れを指します。\n\nコンテナは基本「**使い捨て**」する。コンテナは上で説明した性質から、複数同時稼働させることが多い。これをいちいち1つづつ保守していると手間がかかる。そこで古いコンテナは次々と使い捨てし、新しいイメージからコンテナを作成して乗り換えていくわけです。\n\nちなみにコンテナを捨ててもデータを残せるようにホスト(物理的なマシン)のディスクに[マウント](https://e-words.jp/w/%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88.html#:~:text=IT%E3%81%AE%E5%88%86%E9%87%8E%E3%81%A7%E3%81%AF%E3%80%81%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF,%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%8C%E3%81%82%E3%82%8B%E3%80%82)しそこに保存するようにします。こうすることで他のコンテナともデータを共有することも出来るようになります。(使い捨てのコンテナと一緒に消したくないファイルやデータは気をつけて管理しよう！)\n\nちなみにコンテナはDockerエンジンと違って自動起動の設定がGUIで出来ないので、起動スクリプトの作成が必要。\n\n## Docker Hub\n[**Docker Hub**](https://hub.docker.com/) は公式のDockerレジストリ(Dockerイメージを一元管理するためのリポジトリサービス)です。\n\nTODO ここにわかりやすい図\n\nイメージは基本的にDocker Hubから手に入れる。イメージを1から作るということは初級者が行うことはほぼない。(Docker Hubにあるイメージのバリエーションでほぼ事足りるので。)\n\n# まとめ\n## Dockerのメリット\n- 1台の物理マシンの上に複数のサーバーを載せられる\n- (コンテナの独立性により)サーバーの管理が容易\n- コマンドさえ覚えれば楽にサーバー構築\n## Dockerの使いどころ\n- メンバー全員に同じ開発環境を共有\n- 新しいバージョンのソフトの実験\n- 複数サーバーの運用",
      "body_updated_at": "2021-04-25"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-19",
      "body_markdown": "# Day2 Dockerを使う\n## Dockerのインストール\n以下のサイトのDockerDesktop for Macをクリックしてインストール。\nhttps://docs.docker.com/get-docker/\n\n## dockerコマンドの構成\n![](https://storage.googleapis.com/zenn-user-upload/g40gjj751mial2l4mcuo2ug96tel)\n\n\n## 基本操作\n\n- 下ごしらえ\n\n```\n$ mkdir ~/Documents/docker_pr\n$ cd ~/Documents/docker_pr\n```\n\n### image系\n\n- イメージの取得\n\n```\n$ docker image pull nginx\n```\n\n- イメージの確認\n```\n-- どっちでもいいよ\n$ docker image ls\n$ docker images\nREPOSITORY   TAG       IMAGE ID       CREATED       SIZE\nnginx        latest    62d49f9bab67   11 days ago   133MB\n```\nREPOSITORYがimage名、TAGがバージョン。\n\n- イメージの削除\n```\n$ docker image rm\n```\n\n### container系\n\n- コンテナの作成/起動\n```\n$ docker container run --name ngi000 nginx\n```\n\n実は、\n`docker container run` = `image pull` + `container create` + `container start`\n\n![](https://storage.googleapis.com/zenn-user-upload/5caokvr8ghjvd11jm4hqgo82jazu)\n\n- コンテナの停止/削除\n```\n$ docker container stop コンテナ名\n$ docker container rm コンテナ名\n```\n※コンテナを停止しないと削除出来ない=>さらにコンテナが削除されないと大元のimageも削除出来ない\n\n- コンテナの確認\n```\n$ docker container ps (-a)\n$ docker container ls (-a)\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n15366dc67aa6   nginx     \"/docker-entrypoint.…\"   4 minutes ago   Exited (0) 6 seconds ago             ngi000\n```\n\nコンテナがストップしている場合、素のコマンドでは引っ掛からないが`-a`を着けてやると見つかる。\n※上の例だと`Exited`なのでSTOPしている。これが動いている場合は`UP`になる。\n\n- 応用編 コンテナとの通信\n\n```\n$ docker container run --name ngi001 -d  -p 8080:80 nginx\n```\n\n`-d`はdetouchedでバッググランド処理。`-p`はポート番号の指定。\n```\n-p ホストのポート番号:コンテナのポート番号\n- p 8080:80\n```\n複数のコンテナと通信するならホスト側のポート番号は変えてやる必要がある。\n一方でコンテナ側は変更の必要ない。(imageで大抵ポート番号は決まっているはず)",
      "body_updated_at": "2021-04-25"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-26",
      "body_markdown": "# Day3 Dockerに複数コンテナを入れて運用\n## ネットワーク作成/表示/削除\n```\n$ docker network create ネットワーク名(今回はwordpress000net1)\n$ docker network ls\n$ docker network rm ネットワーク名\n```\n\n## DBコンテナの作成\n```\ndocker container run --name wordpress000 -dit --net=wordpress000net1 \\\n-e MYSQL_ROOT_PASSWORD=myrootpass \\\n-e MYSQL_DATABASE=wordpress000db \\\n-e MYSQL_USER=wordpresskun \\\n-e MYSQL_PASSWORD=wkunpass \\\nmysql \\\n--character-set-server=utf8mb4 \\\n--collation-server=utf8mb4_unicode_ci \\\n--default-authentication-plugin=mysql_native_password\n```\n\n```\n-e MYSQL_ROOT_PASSWORD=rootパスワード\n-e MYSQL_DATABASE=DB領域名\n-e MYSQL_USER=MySQLのユーザー名\n-e MYSQL_PASSWORD=MySQLのパスワード\n```\n\n```\n--character-set-server=文字コードをUTF8に\n--collation-server=照合順序をUTF8に\n--default-authentication-plugin=認証方式を古いもの(native)に\n```\n\n## WordPressコンテナの作成\n```\ndocker container run --name wordpress001 -dit --net=wordpress000net1 -p 8085:80 \\\n-e WORDPRESS_DB_HOST=wordpress000 \\\n-e WORDPRESS_DB_NAME=wordpress000db \\\n-e WORDPRESS_DB_USER=wordpresskun \\\n-e WORDPRESS_DB_PASSWORD=wkunpass \\\nwordpress\n```\n\n```\n-e WORDPRESS_DB_HOST=DBのコンテナ名\n-e WORDPRESS_DB_NAME=DB領域名\n-e WORDPRESS_DB_USER=DBユーザー名\n-e WORDPRESS_DB_PASSWORD=DBのパスワード\n```\n",
      "body_updated_at": "2021-04-26"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-26",
      "body_markdown": "# Day4 Docker応用的な使い方(1/2)\n## コンテナに入る(非推奨？)\n```\ndocker container exec -it コンテナ名 bash\n```\n\n## コンテナとホスト間でファイルをコピーする\n- ホスト=>コンテナ\n```\n$ docker container cp ホスト側パス コンテナ名:コンテナ側パス\n```\n\n- コンテナ=>ホスト\n```\n$ docker container cp コンテナ名:コンテナ側パス ホスト側パス\n```\n\n## ボリュームのマウント\nボリュームとはストレージの一領域を区切ったもの。マウントは取り付ける。\nコンテナの外のボリュームにマウントすることで、データを安全に管理/操作出来る！\n\n### ボリュームマウント(Volume mount) Docker社推奨。\nDocker Engineの管理している領域内にボリュームを作成し、コンテナにマウント。\n\n### バインドマウント(Bind mount)\nDocker Engineの管理していない領域の既に存在しているディレクトリをコンテナにマウント。\n\n| マウント方法 | メリット | デメリット |\n| ---- | ---- | ---- |\n| ボリュームマウント | 環境によってパスが変わらない | 直接ボリュームにアクセス出来ない |\n| バインドマウント | 普通のファイルと同じように扱える | パスが変わる、誤って削除してしまいやすい |\n=>頻繁な変更をするファイルはバインドマウントで！\n※ボリュームにアクセスするには「Linuxのみ入った別のコンテナにマウント」する必要がある\n\n### 記憶領域の作成\n\n```\n$ docker volume create ボリューム名\n$ docker volume rm ボリューム名\n```\n![](https://storage.googleapis.com/zenn-user-upload/a614bkql3pbakvyww0y9jt31lthz)\n\n### 記憶領域をマウント(バインドマウント編)\n- マウント\n```\n-- バインドマウント(ボリュームマウントでもここは同じ)\n$ docker container run (省略) -v 実際の記憶領域パス(ボリューム名)：コンテナの記憶領域パス\n```\n※コンテナを破棄してもちゃんと記憶領域のデータは残っている！\n\n```\ndocker container run --name ngi001 -d -p 8090:80 \\\n-v /Users/kuma/Documents/docker_pr/ngi_folder:/var/www/http nginx\n```\n\n### 記憶領域をマウント(ボリュームマウント編)\n- ボリューム作成\n```\n$ docker volume create ngi001vol1\n$ docker volume ls\n```\n\n- マウント\n```\n$ docker container run --name ngi001 -d -p 8090:80 \\\n-v ngi001vol1:/var/www/http nginx\n```\n\n- ボリュームとコンテナの確認\n```\n$ docker volume inspect ngi001vol1\n[\n    {\n        \"CreatedAt\": \"2021-04-26T09:35:56Z\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/ngi001vol1/_data\",\n        \"Name\": \"ngi001vol1\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n```\nNameとMountPointに注目。\n\n```\n$ docker container inspect ngi001\n\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"ngi001vol1\",\n                \"Source\": \"/var/lib/docker/volumes/ngi001vol1/_data\",\n                \"Destination\": \"/var/www/http\",\n                \"Driver\": \"local\",\n                \"Mode\": \"z\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\nNameとSource、Destinationに注目。\n\n\n# TODO \n- ボリュームマウントの確認方法\n- ボリュームのバックアップ\n",
      "body_updated_at": "2021-04-26"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-26",
      "body_markdown": "# Day5 Docker応用的な使い方(2/2)\n## コンテナのイメージ化 その1「commit」\n```\n$ docker commit コンテナ名 作成するイメージ名\n```\n## コンテナのイメージ化 その2「Dockerfile」\n```\n$ docker build -t 作成するイメージ名 材料フォルダのパス\n```\n※材料フォルダとはコンテナ内部に入れたいファイルなどのこと\n\n実際にやってみる。\nまずはDockerfileの準備\n```\n$ cd /Users/kuma/Documents/docker_pr/ngi_folder\n$ touch Dockerfile\nFROM nginx\nCOPY index.html /\n```\n\n```\n-- コンテナの用意\n$ docker container run --name ngi001 -d -p 8090:80 nginx\ne0bae54d33766ebdb3b3e0e3693ab1172f71a69d04b4b6148d34adbb2f2598a9\n-- イメージの作成\n$ docker build -t original_ngi /Users/kuma/Documents/docker_pr/ngi_folder\n$ docker image ls\ndocker container run --name ngi000 original_ngi\n```\n\n## Dockerファイルの記述\n```\nFROM イメージ名\nCOPY コピー元パス コピー先パス\nRUN Linuxコマンド\n```\n![](https://storage.googleapis.com/zenn-user-upload/mls33tegxcj1qrw41fuwtkkwu3oz)\n![](https://storage.googleapis.com/zenn-user-upload/aa3b3u6dpok7ojqiyg4iqzkhtft4)\n\n## コンテナの改造\n(1)ファイルのやり取り(2)Linuxコマンドでの命令\n\nまずはbashの起動\n```\n$ docker exec (オプション) コンテナ名 /bin/bash\n$ docker run (オプション) イメージ名 /bin/bash\n```\n=>上記を行うと操作対象はDocker Engineでなく該当のコンテナになる。\n元に戻るには\n```\n$ exec\n```\n\n### Dockerでやること、コンテナ内部でやること\nDocker：Docker Engine-コンテナの起動/停止、コンテナ内のファイルやり取り\nコンテナ：ソフトウェアのインストール/実行/停止/設定変更、ファイル操作\n",
      "body_updated_at": "2021-04-28"
    }
  ]
}