{
  "title": "TweepyとTwitter-apiでいろいろ遊んでみた",
  "closed": false,
  "archived": false,
  "created_at": "2020-11-22",
  "comments": [
    {
      "author": "kumamoto",
      "created_at": "2020-11-22",
      "body_markdown": "![](https://storage.googleapis.com/zenn-user-upload/a418fpebwi8de8zhabbb59r5uidp)\n\n# 下準備その1 Twitter api申請(今度まとめて書く)\n\n## 英文での申請手順及び回答例\n下記の質問に答えていく。ある程度以上(300文字)の文字数で書かないと後日メールにて\n詳細を教えてと追加質問が来る。(3回程度でクリアしないとリジェクトされてしまうのでちゃんと答えよう！)\n\n- 1問目 how I plan to use Twitter data and/or APIs\n「Twitterのデータ及びAPIをどのように使う予定ですか？」という質問。\n私は下記のように回答しました。\n[和文]\n私は、自社の製品や自身をプロモートする目的でTwitterを運用する人たちのためのサービスを開発しています。\n\n私が自分のサービスにTwitter apiを使用したいのは主に以下2つの理由からです。\n\n第一に、サービスの登録/ログインにOpenid Connectを用いたいからです。私のサービスはTwitterのユーザー向けであり、彼らがユーザー登録やログインをストレスなく出来るようにするにはこのやり方が良いと考えました。\n\n第二に、\n\n[英文]\nI'm developing a service for Twitter users especially who are looking to promote themselves and their products.\n\nI wanted to use Twitter APIs in my service for two main reasons.\n\n Firstly, I want to use Twitter authentication (OpenID Connect) to register and login to the service.\n My service is for Twitter users. Therefore, I need a function that allows Twitter users to register and log in without stress. Therefore, the feature, “authentication with a Twitter account” is a must for my service.\n\n Secondly, I want to make it easy for users of the service to identify accounts that have unfollowed them and to unfollow or block them from within the service. \n The core value of this service is to make it easy to identify which accounts to unfollow.\nThis feature is especially useful for users who want to improve their follow/follower ratio.\n\nFor these reasons, Twitter APIs are essential to the service I'm currently developing.\n\n[和文]\n[英文]\n\n\n",
      "body_updated_at": "2020-12-30"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-11-22",
      "body_markdown": "# 下準備その2 tweepyのインストールやAPIキーの取得\n\n## APIキー、アクセストークンなどの取得(今度書く)\nまずは[デベロッパー向けのページ](https://developer.twitter.com/ja)にアクセスしましょう。\n![](https://storage.googleapis.com/zenn-user-upload/uin1bn6ktybys1klzoxallcgus0t)\nデベロッパー向けページ右上の『Developer Portal』をクリックしてダッシュボードにアクセスします。\n![](https://storage.googleapis.com/zenn-user-upload/fbw7oqe63tegxjefn0waonw0f1y4)\n\nダッシュボードの中の\n## APIキーなどgitに上げたくない情報を環境変数に設定する\nAPIキーをハードコーディング[hard coding:本来プログラム中に記述すべきでないリソース（エラーメッセージなど）を、直接ソースコード中に埋め込むこと]してしまいそれをgit管理にしてしまうとGitHubなどのホスティングサービスに丸裸のまま公開されるリスクがある。今回はそうしたリスクを避けるため外部APIキーを環境変数に入れてgit管理下から話したシェルスクリプトファイルに保存することにしよう。\n\n### まず環境変数を設定するシェルスクリプトのファイルを作成\nホームディレクトリに.shファイルを作成(筆者はtwit.shという名前にした。)\n.shファイル内に環境変数を設定していく\n``` \necho \"twit.sh stands up\"\n# for 自分のアプリ\nexport CUS_KEY=\"******\"\nexport CUS_KEY_SECRET=\"******\"\n# for 自分のアカウント\nexport ACS_TOKEN=\"******\"\nexport ACS_TOKEN_SECRET=\"******\"\n```\n※普段のプログラミングの感覚で=の間にスペースを開けたりしないこと\n\nこれが無事呼ばれるか念のためテストしよう。\n```\n$ bash twit.sh\ntwit.sh stands up\n```\n\n###つぎに作成したシェルスクリプトがターミナル の立ち上げのたびに呼ばれるようにする。\nまずは.bash_profileに下記を追加。\n```\necho \".bash_porfile stands up\"\n# load .bash_rc\nif [ -f ~/.bashrc ]; then\n    source ~/.bashrc\nfi\n```\nこれでbashにログインしたときに.bashrcが読み込まれる。\n次に.bashrcに下記を追記。\n```\necho \".bashrc stands up\"\n# load twit.sh\nif [ -e ~/twit.sh ]; then\n\tsource ~/twit.sh\nfi\n```\nこれで.bashrcが読み込まれたときにtwit.shが読み込まれる。\n念のためこれもテストしよう。\n```\n$ bash\n.bashrc stands up\ntwit.sh stands up\n```\n問題なさそうなので次へ。\n\n## tweepyのインストール\n```\n$ pip install tweepy\n$ pip list | grep tweepy\ntweepy            3.9.0\n```\n\n",
      "body_updated_at": "2020-11-22"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-11-22",
      "body_markdown": "# Tweepyで遊ぶ(どんどん追記していこう)\n\n## いきなり番外編 Python: オブジェクトのメソッド一覧を取得する\nTweepyと直接の関係はないが調査のとっかかりように便利。\n※参考サイト：[Python: オブジェクトのメソッド一覧を取得する](https://qiita.com/suin/items/b15f908aaf8023a8a1fc)\n```\nfor x in dir(obj):\n    print (x, ':', type(eval(\"obj.\"+x)))\n```\n\n## 設定した外部APIキーを呼び出す\n以後以下のコードが記述済とする。\n```\nimport os\nimport tweepy\n\nCK = os.environ['CUS_KEY']\nCS = os.environ['CUS_KEY_SECRET']\nAT = os.environ['ACS_TOKEN']\nAS = os.environ['ACS_TOKEN_SECRET']\n```\n\n## Twitter apiオブジェクトを作る。\n以後以下のコードが記述済とする。\n```\ndef create_api():\n    auth = tweepy.OAuthHandler(CK, CS)\n    auth.set_access_token(AT, AS)\n    api = tweepy.API(auth)\n    return api\n```\n## ツイートする\n```\n# 普通のツイート\napi.update_status(\"Pythonからの投稿\")\n\n# 特定のツイートへのリプライ\napi.update_status(\"Pythonからのリプ\", ステータスID[in_reply_to_status_id])\n```\n※ちなみにstatus-idは下記の画像で言うと下記赤線部分です。\n![](https://storage.googleapis.com/zenn-user-upload/ddm0zap3dlqe37whse1dkqme4a72)\n\n\n\n## 画像付きでツイートする\n同じディレクトリにiterm.pngという画像があるとする。\n```\napi.update_with_media(status=\"Pythonからの画像付きの投稿\", filename=\"./iterm.png\")\n```\n\n## タイムラインに流れているツイートを見る(上限200件)\n```\ndef show_latest_timeline_text(api):\n    timeline = api.home_timeline(count=200)\n    for i, tweet in enumerate(timeline):\n        print(i, tweet.text)\n```\n\n## 自身のbioを取得する\n```\nme = api.me()\nprint(me.screen_name)\nprint(me.name)\nprint(me.description)\nprint(me.location)\nprint(me.url)\n```\n\n## 自身のアイコンをダウンロードする\n```\n# ./iconにhoge.jpgという名前で保存する\nme = api.me()\nurl = me.profile_image_url\nfile_name = \"./icon/hoge.jpg\"\nresponse = requests.get(url)\nimage = response.content\nwith open(file_name, \"wb\") as f:\n    f.write(image)\n```\n\n## 自身のバナーをダウンロードする\n```\nme = api.me()\nurl = me.profile_banner_url\nfile_name = \"./fuga.png\"\nresponse = requests.get(url)\nimage = response.content\nwith open(file_name, \"wb\") as f:\n    f.write(image)\n```\n\n# カレントディレクトリにfuga.pngという名前で保存する\n```\nme = api.me()\nurl = me.profile_image_url\nfile_name = \"./icon/hoge.jpg\"\nresponse = requests.get(url)\nimage = response.content\nwith open(file_name, \"wb\") as f:\n    f.write(image)\n```\n\n## 自分が追加されている公開リストを表示する\n※フォロー済の鍵垢の公開リストはWeb上では見えないが、apiでは見ることが出来る\n```\nmem_list = api.lists_memberships(screen_name=\"digitalhimiko\")\nfor mem in mem_list:\n    print(\"list: \" + mem.name, \"screen_name: \" + mem.user.screen_name)\n```\n\n## アイコンを変更する。\n同じディレクトリにiconディレクトリを作ってそこに画像を保存する。\n```\n# update icon\nfilename = \"./icon/reading_girl.jpg\"\napi.update_profile_image(filename)\n```\n\n## プロフィール(bioやスクリーンネーム、ロケーション)を変更する\n[update_profile()](http://docs.tweepy.org/en/latest/api.html?highlight=update_profile#API.update_profile)を使おう。\nちなみにリンク先のドキュメントにもある通りnameはスクリーンネーム(@以下じゃない方のユーザー名)で最大20文字。descriptionがいわゆるbioで160文字が上限。\n```\nname = \"pythonから氏名を変更したよ\"\nurl = \"https://zenn.dev/kumamoto\"\nlocation = \"Tokyo\"\ndescription = \"pythonから変更しました\"\napi.update_profile(name = name, url = url, location = location, description = description)\n```\n![](https://storage.googleapis.com/zenn-user-upload/2z9s1iulqaufmwjqpo83z0q3oxab)\n\n## バックグランドイメージを変える(バナー/ヘッダー、アイコンの上の画像)を変える(未検証)\n[update_profile_background_image()](http://docs.tweepy.org/en/latest/api.html?highlight=update_profile_banner()#API.update_profile_background_image)\n```\nfilename = \"\"\napi.update_profile_background_image(filename)\n```\n## ブロック/ブロック解除\n```\n# idというキーワード引数ならスクリーンネームでもuser-idでもどちらでも指定可能\n# 直接引数でも問題なさそう\napi.create_block(id=\"\")\napi.destroy_block(\"\")\n```\n\n## ブロックリスト表示(TODO)\n```\n# これでブロックしたユーザーのスクリーンネームを確認\nblock_list = api.blocks()\nfor b in block_list:\n    print(b.screen_name)\n```\n\n\n",
      "body_updated_at": "2020-12-01"
    }
  ]
}