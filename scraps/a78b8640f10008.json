{
  "title": "[Python]基礎文法の範疇だけど時々忘れちゃうやつまとめていく[ジェネレーター、高階関数、lamda etc,,,]",
  "closed": true,
  "archived": false,
  "created_at": "2020-12-16",
  "comments": [
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "# 高階関数(high order function)\n関数を引数として受け取る関数、あるいは返り値として関数を返す関数のこと。\nPythonでは関数もオブジェクトなので変数に入れたり上述のようなことが出来たりする。\n\n- 例\n```\ndef print_greeting(name):\n    print(f\"{name}さん、こんにちは\")\n\ndef print_morning():\n    print(\"Good morning !!\")\n\ndef print_hello(func):\n    func(\"Kumamoto\") #引数funcを関数のように利用します\n    return print_morning # 関数print_mornigを返す\n\nif __name__ == \"__main__\":\n    en_hello = print_hello(print_greeting) # Kumamotoさん、こんにちは\n    en_hello() # Good morning\n```\n",
      "body_updated_at": "2020-12-16"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "# lambda式\n無名関数。「lamda 引数 : 返り値」って感じで書ける。\n\n- 前提\n本筋からはズレるがif文を下記のように一行で書ける。今回はこれを利用する。\n```\n   # 偶数か判断\n    y = 11\n    x = 0 if y % 2 == 0 else 1\n    print(\"x\", x)  # debug 1\n```\n\n- 例\n```\n    hoge = lambda x: x * x\n    print(hoge(2)) # 4\n    fuga = lambda x, y, z=10: x * y * z\n    print(fuga(2, 3)) # 60\n    piyo = lambda x,y: y if x < y else x\n    print(piyo(10, 3))  # 10\n```",
      "body_updated_at": "2020-12-16"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "# 再帰\n関数の中でまた自分自身を呼ぶ。\nこの[Quoraの記事](https://jp.quora.com/%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0%E3%81%A8%E3%81%AF%E3%81%AA%E3%82%93%E3%81%A7%E3%81%99%E3%81%8B-%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%92%E5%A7%8B%E3%82%81/answers/197241778?ch=2&srid=u8fO01)が直感的な説明をしてくれている。(文字を反転させる関数を例に話を勧めてくれている。本当にわかりやすい！)\n\n```\ndef reverse_str(target_str):\n    if len(target_str) == 1: # 説明だと0になっているが\n        return target_str\n    return reverse_str(target_str[1:]) + target_str[0]\n```\n\n- 例\n```\ndef recursion_hoge(n):\n   if n < 10:\n       return\n   else:\n       print(n)\n       recursion_hoge(n-1)\nif __name__ == \"__main__\":\n    recursion_hoge(12) # 12, 11, 10\n```\n\n- 前提 フィボナッチ数列\n1, 1, 2, 3, 5, 8, 13, 21...\n\n- 発展：再帰を使わないフィボナッチ数列\n```\ndef fib_not_recursion(n):\n    now_n, next_n = 0, 1\n    for i in range(n):\n        now_n, next_n = next_n, next_n + now_n\n    return now_n\n\nLIMIT = 1000\nsequence = [1] * LIMIT\n# dp\ndef fib4(order):\n    if order <= 1:\n        return 1\n    i = 2\n    while order > i:\n        print(\"i\", i)  # debug\n        sequence[i] = sequence[i-1] + sequence[i-2]\n        i += 1\n    return sequence[order]\n\n```\n\n- 発展：再帰を使うフィボナッチ数列\n```\ndef fibo(order):\n    if order <= 2: # (2)特殊パターン\n        return 1\n    return fibo(order-1) + fibo(order-2) # (1)先輩がorderより一つ前と２つ前の数値は出るように関数を書いてくれていた\n\n\ndef fib_with_recursion(n):\n    return 1 if n < 3 else fib(n-1) + fib(n-2)\n\n# memo_recursion\nmemo = [1] * LIMIT\ndef fib3(order):\n    if order <= 1:\n        return 1\n    if memo[order] == 1:\n        memo[order] = fib3(order-1) + fib3(order-2)\n    return memo[order]\n```",
      "body_updated_at": "2021-03-10"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "# ジェネレーター関数\nジェネレーターはリストよりメモリ消費が圧倒的に少ない(sys.getsizeを使って実際試してみましょう)。for文で回すとジェネレーターは尽きる。\n※参考：[リストとジェネレータでメモリ使用量とコストを比較する](https://www.rhoboro.com/2019/03/16/list-or-generator.html)\n\n- 基本: yield、next、send、throwを使う\nyieldが呼び出されるとそのたびに処理がストップし、値が返る\n```\ndef gen_func(num):\n    print(\"generate gen_func\")\n    for n in range(num):\n        yield n\n        print(\"yield実行\")\n\nif __name__ == \"__main__\":\n    gen = gen_func(10) # これだけでは処理は走らない\n    n = next(gen)\n    print(\"n\", n)  # debug\n\n    \"\"\"結果\n    generate gen_func\n    n 0\n    \"\"\"\n\n    n = next(gen)\n    print(\"n\", n)  # debug\n\n    \"\"\"結果\n    yield実行\n    n 1\n    \"\"\"\n\n    n = next(gen)\n    print(\"n\", n)  # debug\n\n    \"\"\"結果\n    yield実行\n    n 2\n    \"\"\"\n\n```\n\nもちろん毎回next()を使うのはだるいので普通は下記のようにやります。\n動き方がこの方が直感的ですね。(nextを使うとyieldで止まってprintはされないことを比較してみて！)\n```\nif __name__ == \"__main__\":\n    gen = gen_func(10)\n    for g in gen:\n        print(\"g\", g)  # debug\n```\n\n- 因数分解的なやつ(実際やるならリストを使ったほうが良いとは思います)\nここでのポイントは「ジェネレーターをnext使わずにfor文を使って回すことが出来る」ということです。\n```\ndef generate_prime_factors(n, n_max):\n    for i in range(1, n_max + 1):\n        if n % (i) == 0:\n            yield i\n            if n // (i) != i:\n                yield int(n // (i))\n\nif __name__ == \"__main__\":\n   n = 72 # 72の因数分解などを出したい\n   max_n = math.sqrt(n) # 素因数を出すにはせいぜい√対象数だけ試行すれば良い\n   gen = generate_prime_factors(n, n_max)\n   for i in gen:\n       print(i)\n  \"\"\"\n  #下記のように順番はそのまま出てくるのでリストを使って普通に後でsortしてprintしたほうが良い\n1\n72\n2\n36\n3\n24\n4\n18\n6\n12\n8\n9\n  \"\"\"\n```\n\nちなみに素因数分解なら下記\n\n```\ndef generator_facotorize(n, n_max):\n    i = 2\n    while n >= i:\n        if n % i == 0:\n            yield i\n            n /= i\n            i = 1\n        i += 1\n```\n\n- 応用: リスト内包表記っぽく(listにするなら[]で囲えば良い)\n```\n# 1~10の中で偶数のみ入る\nnew_gen = (x for x in range(1, 11) if x % 2 == 0)\nfor i in new_gen:\n    print(i)\n```\n\n- sendを使う\nyieldで停止している箇所に値を送る\n\nまずは下準備。\n```\ndef gen_func(num):\n    print(\"generate gen_func\")\n    for n in range(1, num):\n        x = yield n\n        print(x)\n        print(\"yield実行\")\n\nif __name__ == \"__main__\":\n    gen = gen_func(10)\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"n\", n)  # debug\n\n\"\"\"ポイントはxがNoneとなっていること\ngenerate gen_func\nn 1\nx None\nyield実行\nn 2\n\"\"\"\n```\n\nつづいてsendを使用してみます。(上で作った関数は共通)\n```\n# Part1\ngen = gen_func(10)\nn = next(gen)\nprint(n)\n# gen.send(10)\n\"\"\"\ngenerate gen_func\n1\n\"\"\"\n\n# Part2\ngen = gen_func(10)\nn = next(gen)\nprint(n)\nn = gen.send(10)\nprint(n)\n\"\"\"\ngenerate gen_func\n1\nx 10\nyield実行\n2\n\"\"\"\n\n# Part3(若干蛇足)\ngen = gen_func(10)\nn = next(gen)\nn = gen.send(10)\nnext(gen)\nprint(n)\n\n\"\"\"\ngenerate gen_func\nx 10\nyield実行\nx None\nyield実行\n2\n\"\"\"\n\n```\n\n上記よりsendはnextと同様に処理をすすめる+値を送る機能があるとわかる。\n※[公式](https://docs.python.org/ja/3/reference/expressions.html#generator.send)にも「ジェネレータ関数の内部へ値を \"送り\"、実行を再開します」と書いていますね。\n※ちなみにいきなりnextをせずsendをすると「can't send non-None value to a just-started generator\n」とタイプエラーになる\n\n\n- throw\n指定した例外を発生させて処理を終了させる。\n```\n    gen = gen_func(10)\n    n = next(gen)\n    print(n)\n    n = gen.send(100)\n    print(n)\n    gen.throw(ValueError(\"Invalid Value\"))\n    n = next(gen) # ここはもう動かない\n\n\"\"\"\ngenerate gen_func\n1\nx 100\nyield実行\n2\nTraceback (most recent call last):\n  File \"hoge.py\", line 16, in <module>\n    gen.throw(ValueError(\"Invalid Value\"))\n  File \"hoge.py\", line 4, in gen_func\n    x = yield n\nValueError: Invalid Value\n\"\"\"\n\n```\n\nちなみに[公式](https://docs.python.org/ja/3/reference/expressions.html#generator.throw)の説明を借りれば「ジェネレータが中断した位置で type 型の例外を発生させて、そのジェネレータ関数が生成する次の値を返します」ということなので処理自体は進んでいます。これはtry exceptを使えばわかることです。\n\n```\ndef gen_func(num):\n    print(\"generate gen_func\")\n    for n in range(1, num):\n        try:\n            x = yield n\n            print(\"x\", x)  # debug\n            print(\"yield実行\")\n        except Exception as e:\n            print(\"hoge\")\n\nif __name__ == \"__main__\":\n    gen = gen_func(10)\n    n = next(gen)\n    print(n)\n    n = gen.send(100)\n    print(n)\n    n = gen.throw(ValueError(\"Invalid Value\"))\n    print(n)\n    n = next(gen)\n    print(n)\n\n\n\n\"\"\"\ngenerate gen_func\n1\nx 100\nyield実行\n2\nhoge\n3\nx None\nyield実行\n4\n\"\"\"\n\n```\n\n- close\n[公式](https://docs.python.org/ja/3/reference/expressions.html#generator.close)の「ジェネレータ関数が一時停止した時点で GeneratorExit を発生させます」という説明だと例外を投げるだけなのか？と一瞬なりましたが普通にgeneratorを終了させる処理です。\n\n```\nif __name__ == \"__main__\":\n    gen = gen_func(10)\n    n = next(gen)\n    print(n)\n    n = gen.close()\n    print(n)\n    next(gen)\n\n\"\"\"\ngenerate gen_func\n1\nNone\nTraceback (most recent call last):\n  File \"hoge.py\", line 19, in <module>\n    next(gen)\nStopIteration\n\"\"\"\n\n```\n",
      "body_updated_at": "2021-03-21"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "## サブジェネレーター(TODO)\nジェネレーターからジェネレーターを呼び出すことが出来る。呼び出される側をサブジェネレーターと言う。\n「yield from 呼び出し先」と書く。「return」で呼び出し先に値を返すことが出来る。またサブサブジェネレーターが「yield」を使うと呼び出し先(サブジェネレーター)に値が返る。\n- イメージ\nメイン処理 -> ジェネレータ -> サブジェネレーター -> サブサブジェネレーター\n**(サブジェネレーターの)returnでジェネレータに。yieldでメイン処理に値が返る。**\n\n- 基本(準備)\n```\ndef sub_sub_generator():\n    yield \"Sub subのyield\"\n    return \"Sub subのreturn\"\n\ndef sub_generator():\n    yield \"subのyield\"\n    res = yield from sub_sub_generator()\n    print(f\"sub_genでの{res=}\")\n    return \"subのreturn\"\n\ndef origin_generator():\n    yield \"generatorのyield\"\n    res = yield from sub_generator()\n    print(f\"originの{res=}\")\n    return \"originのreturn\"\n```\n- 結果 Part1\n```\nif __name__ == \"__main__\":\n    gen = origin_generator()\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"n\", n)  # debug\n    # n = next(gen)\n    # print(\"ここでストップ(表示されない)\")\n    # print(\"n\", n)  # debug\n```\n\n```\nn generatorのyield\nn subのyield\nn Sub subのyield\n```\n\n- 結果 Part2\n```\nif __name__ == \"__main__\":\n    gen = origin_generator()\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"n\", n)  # debug\n    n = next(gen)\n    print(\"ここでストップ(表示されない)\")\n    print(\"n\", n)  # debug\n```\n\n```\nn generatorのyield\nn subのyield\nn Sub subのyield\nsub_genでのres='Sub subのreturn'\noriginのres='subのreturn'\nTraceback (most recent call last):\n  File \"sub.py\", line 27, in <module>\n    n = next(gen)\nStopIteration: originのreturn\n```\n\n## ジェネレーター結局何に用いるのか\n莫大なデータを格納してもリストと違ってメモリ使用量が少なく済む！！(処理は遅くなる)\nDBから引っ張り出す時に活きてくる。\n\n```\n# list, generator, memory\nimport sys\n\ndef num_generator(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\nif __name__ == \"__main__\":\n    list_a = [i for i in range(100000)]\n    print(sys.getsizeof(list_a))\n    ng = num_generator(100000)\n    print(sys.getsizeof(ng))\n```\n",
      "body_updated_at": "2021-03-21"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-16",
      "body_markdown": "# リスト内包表記\n\n- 例\n```\njump_dict = {1: \"鬼滅の刃\",\n       2: \"呪術廻戦\"}\nhoge_list = [\"a\", \"b\", 1, \"c\", 2]\njump_list = [jump_dict.get(x) for x in hoge_list if type(x) == int]\nprint(\"jump_list\", jump_list)  # debug\n```\n\n- 二重配列をリスト内包表記で\n```\ngrids = [[None] * 3 for _ in range(3)] # 二重配列\n```\n",
      "body_updated_at": "2021-02-03"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-17",
      "body_markdown": "# デコレータ\nデコレータの説明はぶっちゃけ[公式](https://docs.python.org/ja/3/glossary.html)がわかりやすい気がする\n『デコレータの文法はシンタックスシュガーです。次の2つの関数定義は意味的に同じものです:』\n```\ndef f(...):\n    ...\nf = staticmethod(f)\n\n@staticmethod\ndef f(...):\n    ...\n```\n\nちなみにシンタックスシュガーとは、日本語に直せば糖衣構文と言ってまぁある構文をもっと楽(簡潔)に書ける書き方だよということです。\n関数間である処理を共通に利用したい場合によく用いられます。\n\n- 基本(準備)\n\n```\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        print(args[0])\n        if args[0] == 1:\n            return 1\n        print(\"*\" * 100)\n        func(*args, **kwargs)\n        print(\"*\" * 100)\n    return wrapper\n\n@deco\ndef func_a(*args, **kwargs):\n    print(\"func_aを実行\")\n    print(args)\n\n\n@deco\ndef func_b(*args, **kwargs):\n    print(\"func_aを実行\")\n    print(args)\n\nif __name__ == \"__main__\":\n    func_a(2, 3, 5)\n    func_b(1, 3, 5, 7)\n\n```\n\n- 基本(結果)\n\n```\n2\n****************************************************************************************************\nfunc_aを実行\n(2, 3, 5)\n****************************************************************************************************\n1\n```\n\n※追記：[Twitter](https://twitter.com/digitalhimiko/status/1373319172021649411)\n\n```\ndef hoge(func):\n    def wrapper(n):\n        print(\"hoge\")\n        func(n)\n    return wrapper\n\ndef fuga(n):\n    print(n)\n\nif __name__ == \"__main__\":\n    hoge(fuga)(5)\n```\n\n## 補足：クロージャーとエンクロージャー\n[【Python】クロージャ(関数閉方)とは](https://qiita.com/naomi7325/items/57d141f2e56d644bdf5f)",
      "body_updated_at": "2021-04-19"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-17",
      "body_markdown": "# 可変長引数\n*args：可変長のタプル\n**kwargs：可変長の辞書\n```\ndef func_a(*args, **kwargs):\n```\n"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-17",
      "body_markdown": "## map関数\nmap(関数, 引数)\nイテレーターを第二引数で入力として受け取り、\n実行時に第一引数の関数に代入した値を出力する。\n\n- 基本\n下記で標準入力を受け取ってそれを一つづつint型にしたリストを作成できる\n```\nif __name__ == \"__main__\":\n    num_l = list(map(int, input().split()))\n    print(num_l)\n```\n\n- 応用\nlambdaと組み合わせて。\n```\nif __name__ == \"__main__\":\n    list_a = [i for i in range(1, 6)]\n    map_a = map(lambda x: x**2, list_a)\n    for a in map_a:\n        print(a)\n```\n\n- 応用2\n辞書と組わせて。\n```\nif __name__ == \"__main__\":\n    man_info = {\n            \"name\": \"Ichiro\",\n            \"age\": \"18\",\n            \"country\": \"Japan\",\n            }\n    map_man = map(lambda x: x + \",\" + man_info.get(x), man_info)\n    for i in map_man:\n        print(i)\n```\n\n- 応用3\n複数の引数を持つ関数と。\n\n```\ndef calc_two(x, y, sign):\n    if sign == \"plus\":\n        return x + y\n    elif sign == \"minus\":\n        return x - y\n\nif __name__ == \"__main__\":\n    result_map = map(calc_two, range(5), (3, 3, 3, 3, 3), [\"plus\", \"minus\", \"minus\", \"plus\", \"plus\"])\n    for r in result_map:\n        print(r)\n```",
      "body_updated_at": "2020-12-21"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-17",
      "body_markdown": "# クラス オブジェクト指向 前編\nオブジェクト指向は筆者自身がまだ不慣れなためかなり基礎からスタートする。\n\n## Part1 クラスの基礎の基礎\nプロパティ：属性\nメソッド：機能、要は関数\nドキュメンテーション文字列：クラスの説明、helpで呼び出せる\n```\nclass クラス名:\n    \"\"\"ドキュメンテーション文字列\"\"\"\n    プロパティ\n    def メソッド名(self,...):\n\nインスタンス名 = クラス名() # インスタンス化\nhelp(クラス名)\n```\n\n## Part2 2種類のプロパティ\n**クラス変数**と**インスタンス変数**\n\n(1)**クラス変数**\n**オブジェクト同士**で共有することが出来る変数。\n=>あるクラス及びそのクラスからインスタンス化されたインスタンス同士で共有している。\n**メソッド内部ではなくクラス直下に書け！！**\n```\nクラス名.クラス変数\nインスタンス名.__class__.クラス変数\n```\n\n(2)**インスタンス変数**\nインスタンスごとに別々に利用する変数。\nメソッドの内部に記述。\n```\nインスタンス名.インスタンス変数\n```\n\n- 具体例\n```\nclass Hoge():\n    class_val = \"class value\"\n\n    def set_val(self):\n        self.instance_val = \"instance value\"\n\n    def print_val(self):\n        print(f\"クラス変数 = {self.class_val}\")\n        print(f\"インスタンス変数 = {self.instance_val}\")\n        print(f\"くらす変数 = {self.__class__.class_var}\") # この書き方のほうがより正確(selfはインスタンスなので)\n\n\nif __name__ == \"__main__\":\n    instance_hoge = Hoge() # インスタンス化\n    instance_hoge.set_val()\n    instance_hoge.print_val()\n\n    print(Hoge.class_val) # クラスから\n    print(instance_hoge.__class__.class_val) #インスタンスからは__class__を使って\n    print(instance_hoge.class_val) # これもアクセス出来てしまうんだよなぁ。。。\n```\n3つ目がなぜ出来るのかイマイチわかってないので保留。\n=>~~selfがクラス自身を表しクラスの中でself.class_valがアクセス出来るんだしそりゃそうやろって話よ。~~\n=>selfはインスタンスを表す。clsがクラスを表す。(あくまでPEP8で決まったルールであり本質的にはどっちも一緒。)\nいずれにしてもself.\\_\\_class\\_\\_.クラス変数、self.インスタンス変数という書き方が正確だと思う。\n\nなお、class変数はオブジェクト(インスタンス群+そのクラス)間でも当然共有されているので\n```\nhoge1 = Hoge()\nhoge2 = Hoge()\nhoge1.__class__.class_val = \"fuga\"\n\n# 下記の結果はいずれもfuga\nprint(hoge2.__class__.class_val)\nprint(Hoge.class_val)\n```\n※実際クラス変数をid関数で調べれば同じidが出てくる\n※やたら修正するのは駄目\n\nちなみにインスタンス変数は当然共有されない。\n```\n# 結果はinstance value\nprint(hoge.instance_val)\nhoge.instance_val = \"fuga\"\n# 結果は(hogeインスタンスの影響受けず)instance valueのまま！\nprint(hoge2.instance_val)\n```\n\n",
      "body_updated_at": "2021-01-05"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-17",
      "body_markdown": "# クラス オブジェクト指向 中編\n\n## Part3 コンストラクタ (\\__init__)\nコンストラクタとはオブジェクトをインスタンス化する際に呼び出されるメソッドのこと。\n※ほぼ必ず定義！\n\n## Part4 デストラクタ(\\__del__)\nインスタンスを削除する際に呼び出される。\nインスタンスの削除は`del インスタンス名`で良い。\n\n```\n# Part 3 ~ 4\nclass Hoge():\n\n    def __init__(self, name):\n        print(\"nameが初期化されます\")\n        self.name = name # インスタンス変数\n\n    def __del__(self):\n        print(\"デストラクタが実行中\")\n        print(f\"name={self.name}\")\n\n    def print_name(self):\n        print(f\"インスタンス変数 = {self.name}\")\n\nif __name__ == \"__main__\":\n    hoge = Hoge(\"kumamoto\")\n    hoge.print_name()\n    del hoge # delを書かなくてもスクリプトの最後にデストラクタが実行される\n```\n\n## Part5 3種類のメソッド(特殊メソッドを除く)\n**インスタンスメソッド** と **クラスメソッド** 、 **スタティックメソッド**\n\n(1) **インスタンスメソッド**\nクラスから作成したオブジェクト(インスタンス)を用いて呼び出すメソッド(クラスからは当然アクセス出来ない)\n\n\n(2)**クラスメソッド**\nクラスをインスタンス化せずに実行できるメソッド\n**@classmethod**をメソッドの上につける。(デコレータ)\nまた、**cls**を引数に取り、cls.変数でクラス変数にアクセス出来る。(クラスからもインスタンスからもアクセスできる)\n\n※参考：[Difference between 'cls' and 'self' in Python classes? => PEP8](https://stackoverflow.com/questions/4613000/difference-between-cls-and-self-in-python-classes)\n- Always use `self` for the first argument to instance methods.\n- Always use `cls` for the first argument to class methods.\n\n(3)**スタティックメソッド**\n(インスタンスメソッドやクラスメソッドと違って)インスタンス(self)やクラス(cls)が引数に渡されることはない。\n**@staticmethod**をつける。荒く言えば他のメソッドと違い普通の関数と思えば良い\n**クラス変数へもインスタンス変数にもアクセスできない！**(クラスからもインスタンスからもアクセスできる)\n\n\n```\nclass Human():\n    class_name = \"Human\" # クラス変数\n\n    def __init__(self, name, age):\n        self.name = name # インスタンス変数\n        self.age = age # インスタンス変数\n\n    # インスタンスメソッド\n    def print_name(self):\n        print(\"インスタンスメソッド実行\")\n        print(f\"名前は{self.name}、年齢は{self.age}\") # インスタンス変数\n\n    # クラスメソッド\n    @classmethod\n    def print_class_name(cls, msg):\n        print(\"クラスメソッド実行\")\n        print(f\"クラスnameは{cls.class_name}\") # クラス変数\n        print(msg)\n\n    # スタティックメソッド こいつはクラスcls(クラス)やself(インスタンス)を引数に取らない/アクセス出来ない\n    @staticmethod\n    def print_msg(msg):\n        print(\"スタティックメソッド実行\")\n        print(msg)\n\n\nif __name__ == \"__main__\":\n    # クラスメソッド実行\n    Human.print_class_name(\"おはよう\") \n\n    # インスタンスメソッド実行\n    man = Human(\"キズナアイ\", 17)\n    man.print_name()\n\n    # スタティックメソッド実行\n    Human.print_msg(\"クラスから、こんばんは\")\n    man.print_msg(\"インスタンスから、こんばんは\")\n```\n\nスタティックメソッドを使うのは敢えてクラス変数やインスタンス変数にアクセス出来ないようにする制限を設けることで開発メンバーに「これは単なる関数だよ」と明示的に伝えるためのものです。",
      "body_updated_at": "2021-03-22"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-21",
      "body_markdown": "# クラス オブジェクト指向 後編 その1\n\n## Part6 特殊メソッド\n**インスタンスにアクセスする際に特定の処理を実行**すると呼び出されるメソッド\n例)a+bとして実行する時内部的にはa.__add__(b)として呼び出される。\nメジャーな下記についてまず理解しよう。\n※参考：[Python初心者でも__hoge__使いたい！〜特殊属性，特殊メソッドの使い方〜](https://qiita.com/kazetof/items/751be29f208836cf9bf4)\n\n(1)**\\_\\_str\\_\\_**: str(obj)、print(obj)の際に呼び出される。objを文字列として返す。\n\n(2)**\\_\\_bool\\_\\_**: if文で論理値を返すことが出来る\n※\\_\\_bool\\_\\_の中にはどういう場合にTrue/Falseを書いておく\n\n(3)**\\_\\_len\\_\\_**: len()実行時に呼び出される\n\n(4)**\\_\\_eq\\_\\_**: ==の際に呼び出される\n\n(5)**\\_\\_hash\\_\\_**: 文字列をハッシュ値として返す。この関数を定義することでクラスを辞書として扱う時やsetに要素を入れる際に利用する。\n=>[**set, frozenset, dict** のようなハッシュを使ったコレクション型の要素に対する操作から呼び出される！](https://docs.python.org/ja/3/reference/datamodel.html#object.__hash__)=>setやdictに入れたいときに使おう\n※参考：[Python における hashable](https://qiita.com/yoichi22/items/ebf6ab3c6de26ddcc09a)\n※参考2:[set オブジェクトは、固有の hashable オブジェクトの順序なしコレクション 公式](https://docs.python.org/ja/3/library/stdtypes.html#set-types-set-frozenset)\n\n(6)**\\_\\_name\\_\\_**: クラスの名前を表す\n\n(7)**\\_\\_dict\\_\\_**: クラス(obj)の(書き込み可能な) 属性を保存するために使われる辞書またはその他のマッピングオブジェクトです。あくまで**デバック**用に使ってください！\n※補足：アクセスするときは何か処理をしてから返すというようになっていた場合も，それを全部無視してアクセスできてしまうため\n※補足2:名前空間の実装に対する抽象化を侵すことになるって公式に書いてある。\n\n(8)**\\_\\_doc\\_\\_**: \n\n※参考：[公式-特殊メソッド](https://docs.python.org/ja/3/reference/datamodel.html#special-method-names)\n\n以下下記のクラスを共通して使うことにする\n```\nclass Human():\n    \"\"\"This is the Human class for studing class\n    \"\"\"\n\n    class_name = \"Human\"\n\n    def __init__(self, name, age, tel_num):\n        self.name = name\n        self.age = age\n        self.tel_num = tel_num\n\n    def __str__(self):\n        return f\"\"\"class_name: {self.__class__.class_name} \n- name: {self.name} \n- age: {str(self.age)} \n- tel_num: {self.tel_num}\"\"\"\n\n    def __bool__(self):\n        return True if self.age >= 20 else False\n\n    def __len__(self):\n        print(\"__len__ が呼び出された\")\n        return len(self.name)\n\n    def __eq__(self, other):\n        return (self.name == other.name) and (self.tel_num == other.tel_num)\n\n    def __hash__(self):\n        # return hash(self.name) # nameの要素しか見ない\n        # return hash(self.name + self.tel_num) # こういう書き方もあり(もちろん下とハッシュ値は違う)\n        return hash((self.name, self.tel_num))\n\n    def doc_test():\n        \"\"\"This function is for test\n        \"\"\"\n        pass\n\n\n```\n\n(1)**\\_\\_str\\_\\_**\n\n```\n# __str__があるとき\nif __name__ == \"__main__\":\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n\n    print(man, type(man))\n    => Human <class '__main__.Human'>\n\n    man_str = str(man)\n    print(man_str, type(man_str))\n    =>Human <class 'str'>\n\n# __str__がないとき\nif __name__ == \"__main__\":\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n\n    print(man, type(man))\n    => <__main__.Human object at 0x10925b520> <class '__main__.Human'>\n\n    man_str = str(man)\n    print(man_str, type(man_str))\n    => <__main__.Human object at 0x10925b520> <class 'str'>\n```\n\n※＋アルファ\nこんな感じにすればすばやくそのインスタンスの変数を確認出来て便利\n\n```\n    def __str__(self):\n        return f\"\"\"- class_name: {self.__class__.class_name} \n- name: {self.name} \n- age: {str(self.age)} \n- tel_num: {self.tel_num}\"\"\"\n\nif __name__ == \"__main__\":\nprint(man, type(man))\n- class_name: Human\n- name: TakemotoPiano\n- age: 39\n- tel_num: 0120-37-0009 <class '__main__.Human'>\n```\n\n(2)**\\_\\_bool\\_\\_**\n\n```\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n    if man:\n        print(f\"{man.name}さんは20歳以上です\")\n    else:\n        print(f\"{man.name}さんは未成年です\")\n=> TakemotoPianoさんは20歳以上です\n```\n\n(3)**\\_\\_len\\_\\_**\n\n```\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n    print(len(man))\n\n    __len__ が呼び出された\n    13\n    => TakemotoPianoの13と出る！\n```\n\n(5)**\\_\\_hash\\_\\_**\n\n- 前提 ：「hash化とは」を理解する\n\n```\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n\n    print(hash(man.name + man.tel_num))\n    print(hash(\"TakemotoPiano\" + \"0120-37-0009\"))\n=> 上記が同じ結果になる\n```\n\n```\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n    man2 = Human(\"TakemotoPiano\", 29, \"0120-37-0009\")\n    man3 = Human(\"YamahaPiano\", 29, \"3120-37-0009\")\n\n# __hash__がないと\n    set_men = {man, man2, man3}\n=> TypeError: unhashable type: 'Human' #クラスはhash化出来ないと出る！\n\n# __hash__があると\n    set_men = {man, man2, man3}\n    for i, x in enumerate(set_men):\n        print(f\"{i}番目\")\n        print(x)\n\n0番目\nclass_name: Human\n- name: YamahaPiano\n- age: 29\n- tel_num: 3120-37-0009\n1番目\nclass_name: Human\n- name: TakemotoPiano\n- age: 39\n- tel_num: 0120-37-0009\n\n=>上記より、nameとtel_numが両方一緒のインスタンスは入らないことがわかる。\n=>__hash__が下記のような形なら今回は全部入る(全ての要素が同じオブジェクトは今回ないので)\n    def __hash__(self):\n        return hash((self.name, self.age, self.tel_num))\n```\n\n(6)**\\_\\_eq\\_\\_**\n```\nif __name__ == \"__main__\":\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n    man2 = Human(\"TakemotoPiano\", 29, \"0120-37-0009\")\n\n    print(man == man2) # man2がotherになっている\n    => True\n    print(man.__eq__(man2))\n    => True\n```\n\n(7)**\\_\\_dict\\_\\_**\n\n```\nif __name__ == \"__main__\":\n    man = Human(\"TakemotoPiano\", 39, \"0120-37-0009\")\n    print(man.__dict__)\n=> {'name': 'TakemotoPiano', 'age': 39, 'tel_num': '0120-37-0009'}\n```\n\n(8)**\\_\\_doc\\_\\_**\n\n```\n    print(man.__doc__)\n=> This is the Human class for studing class\n    print(man.doc_test.__doc__)\n=> This function is for test\n\n```",
      "body_updated_at": "2020-12-27"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-26",
      "body_markdown": "## 番外編 クラスを使った実例\n\n```\nclass Character:\n\n    def __init__(self, name, hp, offence, defense):\n        AllCharacter.character_append(name)\n        self.name = name\n        self.hp = hp\n        self.offence = offence\n        self.defense = defense\n\n    def attack(self, enemy, critical_point=1):\n        if self.hp <= 0:\n            print(\"キャラクターは死んでいます\")\n            return\n        attack_point = self.offence - enemy.defense\n        attack_point = 1 if attack_point <= 0 else attack_point\n        enemy.hp -= attack_point * critical_point\n        if enemy.hp <= 0:\n            AllCharacter.character_delete(enemy.name)\n\n    def critical_hit(self, enemy):\n        self.attack(enemy, 2) # atack()の使いまわし！selfがないことに注目！\n\nclass AllCharacter:\n    all_characters = []\n    alive_characters = []\n    dead_characters = []\n\n    @classmethod\n    def character_append(cls, name):\n        if name in cls.all_characters:\n            raise CharacterAlreadyExistException(\"キャラクターはすでに存在します\")\n        cls.all_characters.append(name)\n        cls.alive_characters.append(name)\n\n    @classmethod\n    def character_delete(cls, name):\n        cls.dead_characters.append(name)\n        cls.alive_characters.remove(name)\n\nclass CharacterAlreadyExistException(Exception):\n    pass\n\nif __name__ == \"__main__\":\n    character_a = Character(\"A\", 10, 5, 3)\n    character_b = Character(\"B\", 8, 6, 2)\n```",
      "body_updated_at": "2021-01-22"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-26",
      "body_markdown": "# クラス オブジェクト指向 後編 その2\n\n## Part7 継承(Inheritance)\n- **継承**とは？\nある別のクラスからそのクラスの持っている性質を引き継ぐこと。\n例)車(スーパークラス) => 軽自動車 (サブクラス)\nこの時軽自動車は車と同じプロパティ/メソッドを継承する\n\n- **オーバーライド**と**オーバーロード**\n「オーバーライド」とは親クラスと同じ名前、同じ引数、同じ戻り値のメソッドを上書いて再定義すること。\n一方で「オーバーロード」とは引数や返り値が異なるが名称が同一のメソッドを複数定義すること。**Python**では(Javaと違い)引数や戻り値の違うメソッド群を区別しないので下にあるものに上書きされる。そういう意味でPythonではオーバーロード出来ないと言われることがある。\n\n\n### 親クラス Person\n\n```\n# クラスの継承\nclass Person: # 親(スーパー)クラス\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greeting(self):\n        print(f\"hello {self.name}\")\n\n    def say_age(self):\n        print(f\"{self.age} years old\")\n```\n\n\n### まずは最低限の子クラス\nこれでも動く。継承してるから当然！\n\n```\nclass Employee(Person): # Personの機能を継承\n    pass\n\nif __name__ == \"__main__\":\n    e = Employee(\"Kumamoto\", 26)\n    print(\"e.name\", e.name)  # debug\n    print(\"e.age\", e.age)  # debug\n    e.greeting()\n    e.say_age()\n```\n\n### 子クラスを肉付け\n\n見るべきポイントはsuper()による親メソッドのそのままの利用。\nあと、オーバーライド/オーバーロード(仮)。\n\n```\n# クラスの継承\nclass Person: # 親(スーパー)クラス\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greeting(self):\n        print(f\"hello {self.name}\")\n\n    def say_age(self):\n        print(f\"{self.age} years old\")\n\n\nclass Employee(Person): # Personの機能を継承\n    def __init__(self, name, age, number):\n        super().__init__(name, age) # 親クラスのメソッドをsuper()で呼び出し\n        self.number = number\n\n    def say_number(self): # 子クラス特有のメソッド\n        print(f\"my number is {self.number}\")\n\n    def greeting(self): # オーバーライド\n        super().greeting()\n        print(f\"I'm employee phone_num = {self.number}\")\n\n    def greeting(self, num): # オーバーロード\n        super().greeting()\n        print(f\"急に思い立った数字を言います {num}です！\")\n        print(\"\"\"\\\npythonではオーバーロード（引数違いのメソッドを定義する）はできない\n下(今回だとこのメソッドに)に上書きされる/上を実行するとエラーになる\\\n\"\"\")\n\nif __name__ == \"__main__\":\n    man = Employee(\"Kumamoto\", 26, \"001-000-000\")\n    print(\"man.name\", man.name)  # debug\n    print(\"man.age\", man.age)  # debug\n    print(\"man.number\", man.number)  # debug\n    # オーバーロード的なことをしたければnum=Noneなどにして引数があるときとない時で分けるなどが有効か\n    # man.greeting() # TypeError: greeting() missing 1 required positional argument: 'num'\n    man.greeting(num=5)\n    man.say_age()\n```\n\n- **ポリモーフィズム(Polymorphism/多態性)**とは？\nサブクラスを複数作成して、サブクラスごとに**同じ名前のメソッド**をそれぞれ作成し処理の中身を**変える**。呼び出す際には**中身を**意識せずに実行出来るのが嬉しい。\n例)人クラス => アメリカ人クラス/日本人クラス\nこの時アメリカ人クラスの話すのメソッドは英語で、日本人クラスは日本語で実行される。\n\n\n\n\n\n",
      "body_updated_at": "2021-01-24"
    },
    {
      "author": "kumamoto",
      "created_at": "2020-12-27",
      "body_markdown": "## クラス 発展編 多重継承\n多重継承\n\n```\n# クラスの多重継承\nclass ClassA:\n\n    def __init__(self, name):\n        self.a_name = name\n\n    def print_a(self):\n        print(\"ClassAのメソッド実行\")\n        print(f\"a = {self.a_name}\")\n\n    def print_hi(self):\n        print(\"A hi\")\n\nclass ClassB:\n\n    def __init__(self, name):\n        self.b_name = name\n\n    def print_b(self):\n        print(\"ClassBのメソッド実行\")\n        print(f\"b = {self.b_name}\")\n\n    def print_hi(self):\n        print(\"B hi\")\n\nclass NewClass(ClassA, ClassB):\n\n    def __init__(self, a_name, b_name, name):\n        ClassA.__init__(self, a_name)\n        ClassB.__init__(self, b_name)\n        self.name = name\n\n    def print_new_name(self):\n        print(f\"name = {self.name}\")\n\n    def print_hi(self):  # オーバーライド\n        ClassA.print_a(self)\n        ClassB.print_b(self)\n        print(\"NewClass hi\")\n\n\nif __name__ == \"__main__\":\n    sample = NewClass(\"AName\", \"BName\", \"New Class Name\")\n    sample.print_a()\n    sample.print_b()\n    sample.print_new_name()\n    sample.print_hi()\n```\n\n## 補足\n- `ClassA.__init__(self, a_name)`と`super().__init__(a_name)`の違い\n前者はselfを引数に取るが、後者は取らない。これはなぜだろうか。\n\n前者は、親クラスのコンストラクタでもあるインスタンスメソッド（__init__）を子クラスからインスタンス化せずに呼び出しています。そのため第一引数selfにはインスタンス自身が自動的に入ります。\nまた前者はClassAのコンストラクタをスタティックメソッドのように呼び出し、第一引数selfをself(**つまり子クラスのインスタンス**)、第2引数をa_nameとしています。\n\n他実例)\n```\na_instance = ClassA()\na_instance.method_a()\n```\n\nインスタンスメソッドはスタティックメソッドのように実行することもできますがインスタンス化していないため、引数selfには自動的にインスタンスは入りません。そのため、明示的にCLASS.method_a(instance)として、instanceを引数にとならなければならなくなります。\n\n\n\n\n\n\n\n",
      "body_updated_at": "2021-04-07"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-06",
      "body_markdown": "## クラス オブジェクト指向 発展編 メタクラス\n**ポリモーフィズム**の**抽象クラス**をやる前にまずは「クラスを再定義するクラス」であるメタクラスについて学ぼう。\n※抽象クラスの原理はメタクラスを元にしている。\n\nメタクラスは主に「**その定義で良いのかクラスを検証する際に用いる**」\n\nデフォルトのメタクラスはtypeクラスだが、自身で定義することも出来る。\nclass定義時に継承と同じ形で「metaclass=メタクラス名」とすると自身のメタクラスを指定出来る。\n\n※参考：[__new__と__init__の違い](https://python.ms/new/)\n\n```\nclass Meta(type):\n    def __new__(metacls, name, bases, class_dict):\n        # クラスのチェックを行う\n        # name:クラスの名前\n        # bases:継承しているクラス\n        # class_dict:クラスの持っている値、関数等\n        return super().__new__(metacls, name, bases, class_dict)  # typeクラスでクラスを生成\n```\n\n![](https://storage.googleapis.com/zenn-user-upload/ft9yitb1lg4ha6hxhl8z9ois39dn)\n\n\n```\nclass MetaException(Exception):\n    pass\n\nclass Meta1(type):  # type(デフォルトのメタクラス)\n    def __new__(metacls, name, bases, class_dict):\n        print(f\"metacls = {metacls}\")\n        print(f\"name = {name}\")\n        print(f\"bases = {bases}\")\n        print(f\"class_dict = {class_dict}\")\n        # if \"my_var\" not in class_dict.keys():\n        #     raise MetaException(\"my varを定義してください\")\n        for base in bases:  # 継承したくないクラスをここで設定できる(Javaで言うfinalクラス)\n            if isinstance(base, Meta1):\n                raise MetaException(\"継承出来ません\")\n        return super().__new__(metacls, name, bases, class_dict)\n\nclass ClassA(metaclass=Meta1):\n    a = \"123\"\n    my_var = \"hoge\"\n    pass\nclass SubClassA(ClassA):\n    pass\n\nif __name__ == \"__main__\":\n    pass\n```",
      "body_updated_at": "2021-04-07"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-07",
      "body_markdown": "## クラス オブジェクト指向 発展編 ポリモーフィズム(多態性)\n「**ポリモーフィズム**」とはサブクラスを複数作成し、同じメソッドを定義して呼び出す際にどのクラスか意識せずに呼び出すことだ。\n\n\n抽象クラスの抽象メソッドを定義しない子クラスがあると下記のようなエラーコードが出る。\n```\nTypeError: Can't instantiate abstract class Woman with abstract methods say_something\n```\n\n```\nfrom abc import abstractmethod, ABCMeta\n\nclass Human(metaclass=ABCMeta):\n\n    def __init__(self, name):\n        self.name = name\n\n    @abstractmethod\n    def say_something(self):\n        pass\n\n    def say_name(self):\n        print(self.name)\n\n\nclass Man(Human):\n\n    def say_something(self):\n        print(\"おとこ！\")\n\nclass Woman(Human):\n\n    def say_something(self):\n        print(\"おんな！\")\n\nif __name__ == \"__main__\":\n    while True:\n        flag = int(input(\"0か1か入力してください\"))\n        if flag not in (0, 1):\n            print(\"入力が間違ってるよ\")\n            continue\n        elif flag == 0:\n            human = Man(\"Taro\")\n        elif flag == 1:\n            human = Woman(\"Hanako\")\n        human.say_something()\n        break\n```\n\n親クラスが抽象クラスをメタクラスとして指定していて、抽象メソッドが存在している場合は必ずそのメソッドを子クラスで実装する。",
      "body_updated_at": "2021-04-08"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-07",
      "body_markdown": "## クラス オブジェクト指向 発展編 プライベート変数\nカプセル化の前提となるプライベート変数について学ぶ\n\nクラス変数、インスタンス変数は外部からアクセスして値を書き換えることが容易。\nアクセス出来ない(しないでほしいと明確化した)変数、**プライベート変数**を使用しよう。\n※プライベート変数は__variableとアンダースコア２つ付けて定義する\n\n```\nclass Human:\n    # クラス変数のプライベート変数\n    __msg = \"Hello\"\n\n    def __init__(self, name, age):\n        # インスタンス変数のプライベート変数\n        self.__name = name\n        self.__age = age \n\n    # プライベート変数にアクセスするならクラス内から\n    def print_msg(self):\n        print(f\"{self.__msg} name = {self.__name} {self.__age}\")\n\nif __name__ == \"__main__\":\n    taro = Human(\"Taro\", 20)\n    jiro = Human(\"Jiro\", 18)\n    taro.print_msg()\n    # print(\"taro.__name\", taro.__name)  # これはAttributeError: 'Human' object has no attribute '__name'\n    print(\"taro._Human__name\", taro._Human__name)  # 特殊な書き方でアクセス自体は出来る\n    print(\"Human._Human__msg\", Human._Human__msg)  # debug # 特殊な書き方でアクセス自体は出来る\n\n```",
      "body_updated_at": "2021-04-08"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-08",
      "body_markdown": "## クラス オブジェクト指向 発展編 カプセル化 前半\n参考：[python property](https://qiita.com/Sylba2050/items/d6f23ac13a0cc5da0c17)\n参考：[pythonのプロパティのあれこれ](https://qiita.com/cardene/items/8a59d576d360b7568c3a)\nPrivate変数を使う場合にはクラスの外部から変数が見えないようにする(カプセル化)必要があります。\nカプセル化をする場合には`getter`と`setter`を定義して利用しないと変数にアクセスが出来ないようにします。\n\n### カプセル化の方法 その1\nsetter、getter、propery\nproperty関数を使うことで外部的にインスタンス変数のように扱えるが内部的には必ず実行したい処理を走らせることが出来る\n```\ndef get_変数名()\ndef set_変数名()\n変数名 = property(get_変数名, set_変数名)\n```\n\n実際にやってみる。\n\n```\n# getter, setterその1\nclass Human:\n\n    def __init__(self, name, age):\n        self.__name = name\n        self.__age = age \n\n    def get_name(self):\n        print(\"getter nameを呼び出しました\")\n        return self.__name\n\n    def get_age(self):\n        print(\"getter ageを呼び出しました\")\n        return self.__age\n\n    def set_name(self, name):\n        print(\"setter nameを呼び出しました\")\n        self.__name = name\n\n    def set_age(self, age):\n        print(\"setter ageを呼び出しました\")\n        self.__age = age\n\n    name = property(get_name, set_name) # nameを指定するとget_name, set_nameが呼び出される\n    age = property(get_age, set_age) # ageを指定するとget_name, set_nameが呼び出される\n\n\nif __name__ == \"__main__\":\n    human = Human(\"Taro\", 15)\n    human.name = \"Jiro\" # 普通のインスタンス変数にアクセスしているように見えて実はsetterを呼び出し\n    print(\"human.name\", human.name)  # 普通のインスタンス変数にアクセスしているように見えて実はgetter呼び出し\n```",
      "body_updated_at": "2021-04-08"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-08",
      "body_markdown": "## クラス オブジェクト指向 発展編 カプセル化 後半\n\n```\n# getter, setterその2\nclass Human:\n\n    def __init__(self, name, age):\n        self.__name = name\n        self.__age = age \n\n    @property\n    def name(self): # getter\n        print(\"getter nameを呼び出しました\")\n        return self.__name\n\n    @property\n    def age(self):\n        print(\"getter ageを呼び出しました\")\n        return self.__age\n\n    @name.setter\n    def name(self, name):\n        print(\"setter nameを呼び出しました\")\n        self.__name = name\n\n    @age.setter\n    def age(self, age):\n        if age < 0:\n            print(\"0以上の値を入力してね\")\n            return\n        print(\"setter ageを呼び出しました\")\n        self.__age = age\n\n\n\nif __name__ == \"__main__\":\n    human = Human(\"Taro\", 15)\n    human.name = \"Jiro\" # 普通のインスタンス変数にアクセスしているように見えて実はsetterを呼び出し\n    human.age = -13\n    print(\"human.name\", human.name)  # 普通のインスタンス変数にアクセスしているように見えて実はgetter呼び出し\n```\n\n## propetyを使って変数をアクセス専用にする\n\n```\nclass MyProperty(object):\n    def __init__(self, x):\n        self._x = x\n\n    @property\n    def x(self):\n        return self._x\nmypro = MyProperty(100)\nprint(mypro.x) # 100\n\nmypro.x = -200\nAttributeError # 定義されていないのでエラー\n```",
      "body_updated_at": "2021-04-08"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-08",
      "body_markdown": "## 例外処理\n例外処理とは実行時エラーを制御して処理を行うこと。\n\n```\ntry:\n    処理\nexcept エラー名:\n    例外発生時の処理\nelse:\n    例外が発生しなかった場合のみの処理\nfinally:\n    例外の有無に関わらずの処理\n```\n\n### 代表的な例外\n- FileNotFoundError：指定ファイルが見つからない\n- IndexError：配列で指定したインデックスに値が存在しない\n- TypeError：型に関するエラー\n- ZeroDevisionError：0で割ろうとしたことによるエラー\n- Exception：全ての例外\n\n### 具体例1\n\n- スタックトレース\n>In computing, a stack trace (also called stack backtrace or stack traceback) is a report of the active stack frames at a certain point in time during the execution of a program. When a program is run, memory is often dynamically allocated in two places; the stack and the heap.\n\n実行中のコンピュータプログラムにエラーが発生した際に、直前に実行していた関数やメソッドなどの履歴を表示すること。\n\n- スタックとヒープ\nヒープ：ヒープ領域とは、動的に確保と解放を繰り返せるメモリ領域のこと\nスタック：コンパイラやOSによってソフトウェアへの割り当てを決める、、確保したのとは逆の順番で解放する\n\n```\nif __name__ == \"__main__\":\n    try:\n        b = [10, 20, 30]\n        c = b.method_a()\n        a = b[4]\n        a = 10 / 0\n    except ZeroDivisionError as e:\n        import traceback\n        traceback.print_exc()\n        # print(e, type(e))\n    except IndexError as e:\n        print(\"indexerror発生\")\n    except Exception as e:\n        print(\"Exception発生\", e, type(e))\n    else:\n        print(\"Else処理\")\n    finally:\n        print(\"Finally処理\")  # finallyはログ出力などにも利用\n    print(\"処理が完了したよ\")\n```\n\n### 具体例2 例外を返す(raise)と例外クラスの自作\n\n```\nclass MyException(Exception):\n    pass\n\n\ndef devide(a, b):\n    if b == 0:\n        raise ZeroDivisionError(\"0では割り切れません\")\n    elif b < 0:\n        raise MyException(\"今回はマイナスで割らないで\")\n    return a / b\n\nif __name__ == \"__main__\":\n    try:\n        c = devide(10, -1)\n    except Exception as e:\n        print(e, type(e))\n```\n\n",
      "body_updated_at": "2021-04-09"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-09",
      "body_markdown": "## ファイルの入出力とWith\n\n### ファイル入力\n(1)ファイルを開く：`f = open(file_path, mode='r')`、mode='rb'\n(2)ファイルの中身読み込み：`f.read()`、`f.readline()`、`f.readlines()`\n(3)ファイルを閉じる：`f.close()`\n\n(1)と(3)を省略する`with`を普通使う。\n\nセイウチ演算子を用いたファイルのオープン/クローズ\n```\nwith open(\"file.csv\", mode=\"r\") as f:\n    while msg := f.readline():  # msgがNoneになるまで読み込みが続く\n        print(msg)\n```\n\n入力まとめ\n\n```\nif __name__ == \"__main__\":\n    file_path = \"./input.csv\"\n    f = open(file_path, mode=\"r\", encoding=\"utf-8\")\n\n    # 中身全体\n    \"\"\"\n    line = f.read()\n    print(line)\n    \"\"\"\n\n    # 行単位で配列\n    # lines = f.readlines()\n    # lines = [l.rstrip() for l in lines]\n    \"\"\"\n    lines = [l.rstrip() for l in f.readlines()]\n    print(lines)\n    \"\"\"\n\n    # 一行づつ取得\n    # line = f.readline()\n    # while line:\n    #     print(line.rstrip())\n    #     line = f.readline()\n    while line := f.readline():\n        print(line.rstrip())\n\n    f.close()  # 開きっぱなしだとメモリを食う\n\n    with open(file_path, mode=\"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        print(lines)\n```\n\n### ファイル出力\n(1)ファイルを開く：`f = open(file_path, mode='w')`、mode='a'、mode='wb'\n(2)ファイルへの書き込み：`f.write()`、`f.writelines()`、`f.write(\"\\n\".join(list))`、\n\n```\nif __name__ == \"__main__\":\n    file_path = \"./input.csv\"\n    # with open(file_path, mode=\"w\", encoding=\"utf-8\", newline=\"\\n\") as f:  => windowsならこれCRLF変換\n    with open(file_path, mode=\"w\", encoding=\"utf-8\") as f:\n        f.write(\"hoge\\nいい\")\n\n    with open(file_path, mode=\"a\", encoding=\"utf-8\") as f:\n        list_a = [\n                [\"A\", \"B\", \"C\"],\n                [\"a\", \"b\", \"c\"],\n                ]\n        # f.writelines(list_a[0]) # リストの中身がつながって出力\n        for a in list_a:  # これなら指定のつなぎ目で書き込み可能\n            f.write(\"\\n\")\n            f.write(\",\".join(a))\n```\n\n### with詳細\nwithの中の処理を実行する前にwithの後に指定したクラスの`__init__`と`__enter__`がそれぞれ呼ばれ、処理終了後にクラスの`__exit__`メソッドが呼ばれる。\n\n- `with`の使い所\n(1)ファイルの書き込み処理(ファイル開く=>書き込む=>ファイル閉じる)\n(2)DBへのデータの書き込み処理(DBへコネクションを張る=>書き込み=>コネクションを閉じる)\n\n- `with`で使えるクラスの作成\n\n```\nclass WithTest:\n\n    def __init__(self, msg):\n        print(\"init called\")\n        self.msg = msg\n\n    def __enter__(self):\n        print(\"enter called\")\n\n    def __exit__(self, exc_type, exc_val, traceback):  # エラーハンドリングタイプのための引数\n        print(\"exit called\")\n\nif __name__ == \"__main__\":\n    with WithTest(\"Hello\") as t:\n        print(\"withの中\")\n\n-----------\ninit called\nenter called\nwithの中\nexit called\n```\n\n- さらに実用的な`with`で使うクラスの作成\n\n```\nclass WithTest:\n\n    def __init__(self, file_name):\n        print(\"init called\")\n        self.__file_name = file_name\n\n    def __enter__(self):\n        print(\"enter called\")\n        self.__file = open(self.__file_name, mode=\"w\", encoding=\"utf-8\")\n        return self  # as tのtに入る\n\n    def write(self, msg):\n        self.__file.write(msg)\n\n\n    def __exit__(self, exc_type, exc_val, traceback):  # エラーハンドリングタイプのための引数3つ必要\n        print(\"exit called\")\n        self.__file.close()\n\nif __name__ == \"__main__\":\n    with WithTest(\"./input.csv\") as t:\n        print(\"withの中\")\n        t.write(\"fuga\")\n```\n",
      "body_updated_at": "2021-04-09"
    },
    {
      "author": "kumamoto",
      "created_at": "2021-04-09",
      "body_markdown": "## そのほか雑多な話\n\n### 標準入力あれこれ\n\n- 複数行の標準入力を受け取り\n\n```\n-- 入力(最初をn、あとをa_lリストにいれたいとき)\n5\n3\n3\n1\n6\n1\nn, *a_l = map(int, sys.stdin.buffer.read().split())\nprint(\"a_l\", a_l)  # debug\n\n1\n2\n5\n\nnum_l = list(map(int, sys.stdin.buffer.readlines()))\n```\n\n上記のようにbufferオブジェクトを上手く使うこと\n\n\n### bit演算子/シフト演算子\n何方かと言えば、競プロで使う知識\n- 参考\n[Python de アルゴリズム（bit全探索）](https://qiita.com/gogotealove/items/11f9e83218926211083a)\n[【Python】AtCorderに立ち向かうためのbit全探索その1](https://note.com/iifurugi/n/n38b20b6f87ff)\n\n- ２進数の作り方を直感で理解する\n```\n# 普通にbin(num)した方がもちろん早い\ndef convert_bin(num):\n    bin_r = ceil(log2(num))\n    bin_l = [0] * bin_r\n    for i, b in enumerate(range(bin_r-1, -1, -1)):\n        tmp = num - (2 ** b)\n        if tmp >= 0:\n            num = tmp\n            bin_l[i] = 1\n    #joinはListの各要素が全てstrでなくてはならない\n    bin_s = \"\".join(map(str, bin_l))\n    return bin_s\n```\n\n### 切り上げ\n```\nans1 = 4 //3\nprint(ans1) # 1 これは普通に切り捨て\n\nans2 = -(-4 // 3)\nprint(ans2) # 2 なんと！これで切り上げになる\n```\n正確には切り上げではなくmath.floor(x)のx以下で最大の整数になるというルールに従っているだけ。\nたとえばx=-1.3ならx以下の最大の整数は-2となる。\n\n参考：[Floor division with negative number / stackover flow](https://stackoverflow.com/questions/37283786/floor-division-with-negative-number#:~:text=%2F%2F%20in%20Python%20is%20a,(performed%20with%20%2F%20operator).&text=7%20%2F%202%20%3D%203.5%20so%207,of%20%2D3.5%20%3D%20%2D4%20)\n\n### モンティ・ホール問題\n\n```\nimport random\n\nfirst_result = [0, 0]\nchange_result = [0, 0]\n\nfor _ in range(1000):\n    doors = [\"新車\", \"ヤギ\", \"ヤギ\"]\n    random.shuffle(doors)\n    # print(doors)\n    first_select = random.randint(1, 3)\n    # print(\"first_select\", first_select)  # debug\n\n    door_no = [1, 2, 3]\n    door_no.remove(first_select)\n    # print(\"door_no\", door_no)  # debug\n\n    master_select = random.choice(door_no)\n    door_no.remove(master_select)\n\n    if doors[master_select - 1] == \"新車\":\n        master_select, door_no[0] = door_no[0], master_select\n\n    change_select = door_no[0]\n    # print(\"master_select\", master_select)  # debug\n    if doors[first_select - 1] == \"新車\":\n        first_result[0] += 1\n        change_result[1] += 1\n    else:\n        first_result[1] += 1\n        change_result[0] += 1\nprint(\"first_result\", first_result)  # debug\nprint(\"change_result\", change_result)  # debug\n```\n\n## セイウチ演算子 :=\n変数の代入と変数の使用が同時にできる。whileと一緒に使うパターンが多い。\n\n```\nn = 0\nwhile(n:=n+1)<10:\n    print(n)\n```\n\n## f文字列で小数点を指定\n\n```\ndivision = a // b\nmodulo = a % b\nf_division = a / b\nprint(f\"{division} {modulo} {f_division:.6f}\")\n```\n\n\n## 標準入力あれこれ\n\n```\nimport sys\nreadlines = sys.stdin.buffer.readlines # 複数行全てリスト,各要素全てbyteになってるけどあくまでリスト！\nmap_readlines = lambda: map(int, readlines()) # 上を全てintにしたmap\nreadline = sys.stdin.buffer.readline # 一行スペース空きをbyteで取る 毎回\\nがツイてくる\nmap_readline = lambda: map(int, readline().split()) #上の各要素をintにしたmap\nsreadline = lambda: readline().decode(\"utf-8\").rstrip() # 上の要素を文字列にして合体\n# read = sys.stdin.buffer.read # 複数行全てbyte、これはreadlinesと違ってリストにならない、ほぼ使わない\n# read = sys.stdin.read # 複数行を複数行のまま文字列で取ってくる これはstr、使わない\n# readline = sys.stdin.readline # 一行を文字列で、これはstr \\nがツイてくる\n# readlines = sys.stdin.readlines # 一行を文字列で、これもstr、毎度\\nがツイてくる\n\n\n# 普通は\ninput()\n```\n\n文字列を出すだけなら非buffer、intにするならbufferのほうがいいかも\n※非bufferは最初からstrなので。\n\n## 有効桁で切り捨て\n\n```\n# 小数点第三位まで\ndef truncate(num):\n    return math.floor(num * 1000) / 1000\n```"
    }
  ]
}